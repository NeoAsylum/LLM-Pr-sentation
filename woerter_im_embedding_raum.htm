<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Embedding 3D Visualisierung</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        #canvas-container {
            width: 100%;
            height: 70vh; /* Increased height for better view */
            cursor: grab;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="relative w-full h-screen flex flex-col items-center justify-center p-4">
        <div class="text-center mb-4 z-10">
            <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-indigo-400">Word Embedding Raum</h1>
            <p class="text-gray-400 mt-2 text-lg">Wie KI die Bedeutung von Wörtern versteht</p>
        </div>
        
        <div id="canvas-container" class="rounded-xl border border-gray-700 bg-gray-800/20"></div>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <script>
        // --- Basic Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 2;
        controls.maxDistance = 50; // Increased max distance

        camera.position.set(8, 4, 12); // Better initial camera position
        
        const rotatingGroup = new THREE.Group();
        scene.add(rotatingGroup);
        
        rotatingGroup.rotation.x = 0.2;

        // --- Grid and Axes ---
        const gridHelper = new THREE.GridHelper(30, 30, 0x444444, 0x333333);
        gridHelper.position.y = -8; // Lower the grid
        rotatingGroup.add(gridHelper);

        const axisLength = 10;
        const axesData = [
            { dir: new THREE.Vector3(1, 0, 0), color: 0xff7777, label: 'X' },
            { dir: new THREE.Vector3(0, 1, 0), color: 0x77ff77, label: 'Y' },
            { dir: new THREE.Vector3(0, 0, 1), color: 0x7777ff, label: 'Z' }
        ];

        // --- Data: Words and their 3D coordinates ---
        const words = [
            { text: 'Ich', position: new THREE.Vector3(-4, 3, -2), color: 0xffffff },
            { text: 'würde', position: new THREE.Vector3(-2, 2, 0), color: 0xffffff },
            { text: 'wüsste', position: new THREE.Vector3(-2.5, 1, 1), color: 0xffffff },
            { text: 'gerne', position: new THREE.Vector3(-1, 0, 0), color: 0xffffff },
            { text: 'Geld', position: new THREE.Vector3(2, 0.5, 1), color: 0x22d3ee }, // cyan-400
            { text: 'abheben', position: new THREE.Vector3(4, 1, 1.5), color: 0xffffff },
            { text: 'Geldautomat', position: new THREE.Vector3(2.5, -0.5, 1.2), color: 0x22d3ee }, // cyan-400
            { text: 'befindet', position: new THREE.Vector3(1, -3, -2), color: 0xffffff },
            { text: 'nächste', position: new THREE.Vector3(-1, -2.5, -3), color: 0xffffff },
            { text: 'wo', position: new THREE.Vector3(-0.5, -4, -1), color: 0xffffff },
            { text: 'sich', position: new THREE.Vector3(0, -3.5, 0), color: 0xffffff },
            { text: 'der', position: new THREE.Vector3(-1.5, -2, -2), color: 0xffffff },
        ];
        
        // Array to hold the text labels for updating their positions
        const textLabels = [];

        // --- Create Objects in Scene ---
        const fontLoader = new THREE.FontLoader();
        fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/gentilis_regular.typeface.json', (font) => {
            // Add Axes Lines and Labels
            axesData.forEach(axis => {
                // Positive Axis
                let geometry = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), axis.dir.clone().multiplyScalar(axisLength) ]);
                let line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: axis.color, linewidth: 2 }));
                rotatingGroup.add(line);
                
                // Negative Axis (dashed)
                geometry = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), axis.dir.clone().multiplyScalar(-axisLength) ]);
                const lineDashed = new THREE.Line(geometry, new THREE.LineDashedMaterial({ color: axis.color, dashSize: 0.5, gapSize: 0.2, linewidth: 2 }));
                lineDashed.computeLineDistances();
                rotatingGroup.add(lineDashed);


                if (axis.label) {
                    const textGeo = new THREE.TextGeometry(axis.label, {
                        font: font,
                        size: 0.5,
                        height: 0.05,
                    });
                    textGeo.center();
                    const textMat = new THREE.MeshBasicMaterial({ color: axis.color });
                    const textMesh = new THREE.Mesh(textGeo, textMat);
                    textMesh.position.copy(axis.dir.clone().multiplyScalar(axisLength + 0.8));
                    rotatingGroup.add(textMesh);
                }
            });

            words.forEach(word => {
                // Create sphere for the word
                const sphereGeometry = new THREE.SphereGeometry(0.15, 32, 32);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: word.color });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(word.position);
                rotatingGroup.add(sphere);

                // Create text label
                const textGeometry = new THREE.TextGeometry(word.text, {
                    font: font,
                    size: 0.3,
                    height: 0.02,
                });
                textGeometry.center();
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xe5e7eb });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                
                // FIXED: Add a reference from the text to its sphere
                textMesh.userData.sphere = sphere;
                textLabels.push(textMesh);
                scene.add(textMesh); 
            });
        });

        // --- Draw Lines between similar words ---
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x0891b2, transparent: true, opacity: 0.7 });
        const points = [];
        const geld = words.find(w => w.text === 'Geld').position;
        const geldautomat = words.find(w => w.text === 'Geldautomat').position;
        points.push(geld, geldautomat);
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        rotatingGroup.add(line);
        
        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (!controls.autoRotate) {
                 rotatingGroup.rotation.y -= 0.002;
            }
            
            // FIXED: Update text positions based on their linked sphere's world position
            textLabels.forEach(label => {
                const sphere = label.userData.sphere;
                const worldPosition = new THREE.Vector3();
                
                // Get the sphere's current position in world coordinates
                sphere.getWorldPosition(worldPosition);
                
                // Update the label's position to follow the sphere, with an offset
                label.position.copy(worldPosition).add(new THREE.Vector3(0, 0.4, 0));
                
                // Make the label face the camera
                label.quaternion.copy(camera.quaternion);
            });

            renderer.render(scene, camera);
        }
        animate();

        // --- Handle Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>
