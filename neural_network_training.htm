<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neuronales Netz Backpropagation Animation</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .link {
            stroke-width: 3px;
            stroke-opacity: 1.0;
            filter: drop-shadow( 0px 0px 1.5px black );
        }
        .node {
            stroke: #4b5563;
            stroke-width: 1px;
        }
        .node-label, .weight-label {
            font-size: 12px;
            font-family: monospace;
            fill: #1f2937;
            pointer-events: none;
        }
        .delta-label {
            font-size: 11px;
            font-family: monospace;
            font-weight: bold;
            pointer-events: none;
        }
        .ellipsis-label {
            font-size: 24px;
            font-weight: bold;
            fill: #9ca3af;
            text-anchor: middle;
        }
        .input-label {
            font-size: 14px;
            font-weight: 500;
            fill: #374151;
            text-anchor: end;
        }
        .output-label {
            font-size: 14px;
            font-weight: 500;
            fill: #374151;
            text-anchor: start;
        }
        .status-text {
             font-size: 16px;
             font-weight: 500;
             fill: #1f2937;
             text-anchor: middle;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Training eines Neuronalen Netzwerks</h1>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
            <!-- Left Panel: Info -->
            <div class="lg:col-span-1 bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Aktuelles Beispiel</h2>
                 <div class="bg-gray-50 p-3 rounded-lg text-center">
                    <p class="font-medium text-gray-800">Eingabe: <span id="input-values" class="font-mono"></span></p>
                    <p class="font-medium text-gray-800">Ziel: <span id="target-values" class="font-mono"></span></p>
                </div>

                <h2 class="text-2xl font-semibold my-4 border-b pb-2">Status</h2>
                <div id="status-box" class="space-y-2 text-gray-700 bg-gray-50 p-3 rounded-lg h-32 flex items-center justify-center">
                   <p class="text-center">Animation startet in 3 Sekunden...</p>
                </div>
            </div>

            <!-- Right Panel: Network Visualization -->
            <div class="lg:col-span-3 bg-white p-6 rounded-2xl shadow-lg">
                <div id="network-visualization" class="w-full h-[450px] flex justify-center items-center"></div>
            </div>
        </div>
    </div>

    <script>
        // --- Neural Network Implementation ---
        const sigmoid = x => 1 / (1 + Math.exp(-x));
        const sigmoidDerivative = x => x * (1 - x);

        class NeuralNetwork {
             constructor(inputNodes, hiddenNodes, outputNodes) {
                this.inputNodes = inputNodes;
                this.hiddenNodes = hiddenNodes;
                this.outputNodes = outputNodes;
                this.learningRate = 0.7;
                this.reset();
            }

            reset() {
                this.weights_ih = Array.from({ length: this.hiddenNodes }, () => Array.from({ length: this.inputNodes }, () => Math.random() * 0.5 - 0.25));
                this.weights_ho = Array.from({ length: this.outputNodes }, () => Array.from({ length: this.hiddenNodes }, () => Math.random() * 0.5 - 0.25));
                this.bias_h = Array.from({ length: this.hiddenNodes }, () => Math.random() * 0.5 - 0.25);
                this.bias_o = Array.from({ length: this.outputNodes }, () => Math.random() * 0.5 - 0.25);
            }

            feedforward(inputArray) {
                this.inputs = inputArray;
                this.hidden = this.weights_ih.map((weights, i) => {
                    const sum = weights.reduce((acc, w, j) => acc + w * inputArray[j], 0);
                    return sigmoid(sum + this.bias_h[i]);
                });
                this.outputs = this.weights_ho.map((weights, i) => {
                    const sum = weights.reduce((acc, w, j) => acc + w * this.hidden[j], 0);
                    return sigmoid(sum + this.bias_o[i]);
                });
                return this.outputs;
            }

            calculateDeltas(targetArray) {
                const outputErrors = targetArray.map((target, i) => target - this.outputs[i]);
                
                // Calculate output layer gradients (delta_k * learning_rate)
                const outputGradients = this.outputs.map((o, i) => sigmoidDerivative(o) * outputErrors[i] * this.learningRate);

                // Calculate output deltas (used for backpropagation)
                const outputDeltas = this.outputs.map((o, i) => sigmoidDerivative(o) * outputErrors[i]);

                // Calculate hidden layer errors by backpropagating output deltas
                const hiddenErrors = this.weights_ho[0].map((_, h) => 
                    this.weights_ho.reduce((acc, weights, o) => acc + weights[h] * outputDeltas[o], 0)
                );

                // Calculate hidden layer gradients (delta_h * learning_rate)
                const hiddenGradients = this.hidden.map((h, i) => sigmoidDerivative(h) * hiddenErrors[i] * this.learningRate);

                // Calculate weight changes
                this.delta_ho = outputGradients.map(og => this.hidden.map(h => og * h));
                this.delta_o_bias = [...outputGradients];
                
                this.delta_ih = hiddenGradients.map(hg => this.inputs.map(i => hg * i));
                this.delta_h_bias = [...hiddenGradients];
            }

            applyDeltas() {
                this.weights_ho = this.weights_ho.map((weights, o) => 
                    weights.map((w, h) => w + this.delta_ho[o][h])
                );
                this.bias_o = this.bias_o.map((b, i) => b + this.delta_o_bias[i]);

                this.weights_ih = this.weights_ih.map((weights, h) => 
                    weights.map((w, i) => w + this.delta_ih[h][i])
                );
                this.bias_h = this.bias_h.map((b, i) => b + this.delta_h_bias[i]);
            }
        }

        // --- Visualization Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            const network = new NeuralNetwork(3, 4, 2);
            
            const examples = [
                { inputs: [0.9, 0.2, 0.1], targets: [1, 0], label: "Tulpe" },
                { inputs: [0.4, 0.9, 0.8], targets: [0, 1], label: "Rose" },
                { inputs: [0.8, 0.3, 0.2], targets: [1, 0], label: "Tulpe" },
                { inputs: [0.5, 0.8, 0.9], targets: [0, 1], label: "Rose" }
            ];
            let exampleIndex = 0;

            const statusBox = document.getElementById('status-box');

            const svgContainer = d3.select("#network-visualization");
            const width = svgContainer.node().getBoundingClientRect().width;
            const height = svgContainer.node().getBoundingClientRect().height;
            const svg = svgContainer.append("svg").attr("width", width).attr("height", height);

            const nodeRadius = 15;
            const inputLabels = ["Stiellänge", "Blütenfarbe", "Blattform"];
            const outputLabels = ["Tulpe", "Rose"];

            const nodes = {
                input: d3.range(network.inputNodes).map(i => ({ layer: 0, index: i, label: inputLabels[i] })),
                hidden: d3.range(network.hiddenNodes).map(i => ({ layer: 1, index: i })),
                output: d3.range(network.outputNodes).map(i => ({ layer: 2, index: i, label: outputLabels[i] }))
            };
            const allNodes = [...nodes.input, ...nodes.hidden, ...nodes.output];
            const visibleNodes = allNodes.filter(d => d.layer !== 1 || d.index === 0 || d.index === network.hiddenNodes - 1);

            const layerOffsets = [width * 0.15, width * 0.5, width * 0.9];
            allNodes.forEach(node => {
                node.x = layerOffsets[node.layer];
                const layerKey = Object.keys(nodes)[node.layer];
                const layerNodes = nodes[layerKey];
                const ySpacing = height / (layerNodes.length + 1);
                node.y = (node.index + 1) * ySpacing;
            });

            const weightColor = d3.scaleDiverging(d3.interpolatePiYG).domain([1, 0, -1]);

            const linkGroup = svg.append("g").attr("class", "links");
            const nodeGroup = svg.append("g").attr("class", "nodes");
            const labelGroup = svg.append("g").attr("class", "labels");

            function getLinksAndDeltas() {
                const links = [];
                nodes.input.forEach((iNode, i) => {
                    nodes.hidden.forEach((hNode, h) => {
                        links.push({ 
                            source: iNode, 
                            target: hNode, 
                            weight: network.weights_ih[h][i],
                            delta: network.delta_ih ? network.delta_ih[h][i] : 0
                        });
                    });
                });
                nodes.hidden.forEach((hNode, h) => {
                    nodes.output.forEach((oNode, o) => {
                        links.push({ 
                            source: hNode, 
                            target: oNode, 
                            weight: network.weights_ho[o][h],
                            delta: network.delta_ho ? network.delta_ho[o][h] : 0
                        });
                    });
                });
                return links;
            }
            
            const visibleLinksFilter = d => {
                if (d.target.layer === 1) return d.target.index === 0 || d.target.index === network.hiddenNodes - 1;
                if (d.source.layer === 1) return d.source.index === 0 || d.source.index === network.hiddenNodes - 1;
                return false;
            };

            function drawStaticElements() {
                 labelGroup.selectAll(".input-label").data(nodes.input).join("text")
                    .attr("class", "input-label")
                    .attr("x", d => d.x - nodeRadius - 15).attr("y", d => d.y + 5)
                    .text(d => d.label);

                labelGroup.selectAll(".output-label").data(nodes.output).join("text")
                    .attr("class", "output-label")
                    .attr("x", d => d.x + nodeRadius + 15).attr("y", d => d.y + 5)
                    .text(d => d.label);
                
                nodeGroup.selectAll("circle").data(visibleNodes).join("circle")
                    .attr("class", "node")
                    .attr("cx", d => d.x).attr("cy", d => d.y)
                    .attr("r", nodeRadius)
                    .style("fill", "#f3f4f6");
                
                // Add ellipsis
                const firstHidden = nodes.hidden[0];
                const lastHidden = nodes.hidden[nodes.hidden.length - 1];
                labelGroup.append("text")
                    .attr("class", "ellipsis-label")
                    .attr("x", firstHidden.x)
                    .attr("y", (firstHidden.y + lastHidden.y) / 2 + 8)
                    .text("...");
            }

            function updateDynamicElements(duration = 500) {
                const links = getLinksAndDeltas();
                const visibleLinks = links.filter(visibleLinksFilter);
                
                linkGroup.selectAll("line").data(visibleLinks).join(
                    enter => enter.append("line")
                        .attr("class", "link")
                        .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x).attr("y2", d => d.target.y)
                        .style("stroke", d => weightColor(d.weight)),
                    update => update.transition().duration(duration)
                        .style("stroke", d => weightColor(d.weight))
                );

                labelGroup.selectAll(".weight-label").data(visibleLinks).join(
                    enter => enter.append("text"),
                    update => update.transition().duration(duration)
                )
                .attr("class", "weight-label")
                .attr("x", d => (d.source.x + d.target.x) / 2)
                .attr("y", d => (d.source.y + d.target.y) / 2 - 5)
                .attr("text-anchor", "middle")
                .text(d => d.weight.toFixed(3));
                
                labelGroup.selectAll(".node-label").data(visibleNodes).join("text")
                    .attr("class", "node-label")
                    .attr("x", d => d.x).attr("y", d => d.y + 4)
                    .attr("text-anchor", "middle")
                    .text(d => {
                        if (d.layer === 0 && network.inputs) return network.inputs[d.index].toFixed(2);
                        if (d.layer === 1 && network.hidden) return network.hidden[d.index].toFixed(2);
                        if (d.layer === 2 && network.outputs) return network.outputs[d.index].toFixed(2);
                        return '';
                    });
            }

            async function animationStep() {
                const example = examples[exampleIndex];
                
                // Update example display
                document.getElementById('input-values').textContent = `[${example.inputs.join(', ')}]`;
                document.getElementById('target-values').textContent = `[${example.targets.join(', ')}] (${example.label})`;

                // 1. Forward Pass
                statusBox.innerHTML = `<p class="font-semibold text-blue-600">Vorwärtsdurchlauf...</p>`;
                network.feedforward(example.inputs);
                updateDynamicElements();
                await new Promise(r => setTimeout(r, 1000));

                // 2. Calculate Error
                const outputs = network.outputs;
                const target = example.targets;
                const error = [target[0] - outputs[0], target[1] - outputs[1]];
                statusBox.innerHTML = `
                    <p class="font-semibold text-red-600">Fehlerberechnung</p>
                    <p class="font-mono text-sm">(${error[0].toFixed(2)}, ${error[1].toFixed(2)})</p>
                `;
                await new Promise(r => setTimeout(r, 1000));

                // 3. Calculate Deltas
                statusBox.innerHTML = `<p class="font-semibold text-yellow-600">Berechne Gewichtsänderungen...</p>`;
                network.calculateDeltas(example.targets);
                
                const visibleLinks = getLinksAndDeltas().filter(visibleLinksFilter);
                labelGroup.selectAll(".delta-label").data(visibleLinks).join("text")
                    .attr("class", "delta-label")
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2 + 15)
                    .attr("text-anchor", "middle")
                    .style("fill", d => d.delta >= 0 ? "#16a34a" : "#dc2626")
                    .text(d => (d.delta >= 0 ? "+" : "") + d.delta.toFixed(3))
                    .style("opacity", 0)
                    .transition().duration(500)
                    .style("opacity", 1);

                await new Promise(r => setTimeout(r, 1500));

                // 4. Apply Deltas
                statusBox.innerHTML = `<p class="font-semibold text-green-600">Änderungen anwenden...</p>`;
                network.applyDeltas();
                updateDynamicElements();
                
                labelGroup.selectAll(".delta-label")
                    .transition().duration(500)
                    .style("opacity", 0)
                    .remove();

                await new Promise(r => setTimeout(r, 1000));
                
                exampleIndex = (exampleIndex + 1) % examples.length;
            }

            // Initial render
            const initialExample = examples[0];
            document.getElementById('input-values').textContent = `[${initialExample.inputs.join(', ')}]`;
            document.getElementById('target-values').textContent = `[${initialExample.targets.join(', ')}] (${initialExample.label})`;
            drawStaticElements();
            updateDynamicElements(0);

            // Start animation automatically
            setTimeout(() => {
                animationStep(); // Run first step immediately
                setInterval(animationStep, 5000); // Continue every 5 seconds
            }, 3000);
        });
    </script>
</body>
</html>